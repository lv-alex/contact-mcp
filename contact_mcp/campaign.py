"""Campaign module for creating and managing campaigns.

This module handles campaign insert operations for the contact MCP server.
Campaigns are inserted into LVOUSR.CAMPAIGN table via Oracle DB links.
"""

from dataclasses import dataclass
from datetime import date, datetime
from typing import Any, Mapping


# Campaign columns that map to Oracle table columns
CAMPAIGN_COLUMNS = {
    "campaign_id",
    "client_id",
    "filename",
    "start_time",
    "end_time",
    "leave_messages",
    "operator_phone",
    "callback_phone",
    "caller_id",
    "voice_id",
    "extra_4",
    "extra_5",
    "extra_6",
    "extra_10",
    "extra_16",
    "extra_17",
    "extra_18",
    "extra_19",
    "extra_20",
    "b_active",
    "processed",
    "date_modified",
    "processed_filename",
    "skill_id",
    "file_complete",
    "at",
    "et",
    "ct",
    "mt",
    "pt",
    "al",
    "hi",
    "vcr",
    "pending",
    "seed",
    "date_run",
    "am_option",
    "dialing_strategy_id",
    "parent_skill_id",
    "requeue_degree",
    "parent_date_run",
    "actual_start_time",
    "actual_end_time",
    "dialing_restriction_reg_id",
    "scrub_wireless",
    "parent_campaign_id",
    "seed_campaign_id",
    "create_date",
    "upload_date",
    "build_date",
    "first_play_date",
    "upload_user_id",
    "build_user_id",
    "first_play_user_id",
    "current_instance_campaign_id",
    "job_status",
    "eoc_job_completion_time",
    "checksum",
    "split_id",
    "part_id",
    "campaign_type_id",
    "safe",
    "uk",
    "cht",
    "partition_state_id",
    "callerid_source_id",
    "callback_phone_source_id",
    "operator_phone_source_id",
    "inp_mapping_id",
    "build_sort_id",
    "message_id",
    "campaign_template_id",
    "is_requeue",
    "uploaded",
    "is_appendable",
    "contact_source",
    "email_from",
    "campaign_subtype",
    "cet",
    "ist",
}


@dataclass
class CampaignInsert:
    """Represents a campaign INSERT statement."""

    sql: str
    params: dict[str, Any]
    returning_column: str = "campaign_id"


@dataclass
class CampaignQuery:
    """Represents a campaign SELECT statement."""

    sql: str
    params: dict[str, Any]


# Default columns to return for campaign SELECT (most commonly needed)
CAMPAIGN_SELECT_COLUMNS = [
    "CAMPAIGN_ID",
    "CLIENT_ID",
    "FILENAME",
    "SKILL_ID",
    "B_ACTIVE",
    "START_TIME",
    "END_TIME",
    "CREATE_DATE",
    "DATE_MODIFIED",
    "AM_OPTION",
    "CAMPAIGN_TYPE_ID",
    "CONTACT_SOURCE",
    "JOB_STATUS",
]


def _convert_to_date(value: Any) -> Any:
    """Convert string dates to Python date/datetime objects for Oracle binding.

    Args:
        value: Value to potentially convert

    Returns:
        Original value or converted date/datetime object
    """
    if isinstance(value, (date, datetime)):
        return value
    if not isinstance(value, str):
        return value

    formats = [
        "%Y-%m-%d",
        "%d-%b-%Y",
        "%d-%b-%y",
        "%b %d, %Y",
        "%Y-%m-%d %H:%M:%S",
        "%d-%b-%Y %H:%M:%S",
    ]

    for fmt in formats:
        try:
            parsed = datetime.strptime(value, fmt)
            if "%H" in fmt or "%M" in fmt or "%S" in fmt:
                return parsed
            return parsed.date()
        except ValueError:
            continue

    return value


def build_campaign_insert(
    data: Mapping[str, Any],
) -> CampaignInsert:
    """Build an INSERT statement for creating a campaign in the config DB.

    Campaigns are always inserted into the Oracle config database directly,
    not via DB links. The campaign table is LVOUSR.CAMPAIGN.

    Args:
        data: Dictionary of column names to values

    Returns:
        CampaignInsert with SQL and parameters

    Raises:
        ValueError: If required columns are missing or invalid columns provided
    """
    if not data:
        raise ValueError("Campaign data cannot be empty")

    if "client_id" not in data:
        raise ValueError("client_id is required for campaign insert")

    # Normalize column names to lowercase
    normalized_data = {k.lower(): v for k, v in data.items()}

    # Validate columns
    invalid_cols = set(normalized_data.keys()) - CAMPAIGN_COLUMNS
    if invalid_cols:
        raise ValueError(f"Invalid campaign columns: {sorted(invalid_cols)}")

    # Build column and value lists
    columns = []
    params = {}

    for col, value in normalized_data.items():
        if col == "campaign_id":
            # Skip - auto-generated by trigger
            continue

        columns.append(col.upper())

        # Convert dates for Oracle binding
        if col in {
            "start_time",
            "end_time",
            "date_modified",
            "date_run",
            "parent_date_run",
            "actual_start_time",
            "actual_end_time",
            "create_date",
            "upload_date",
            "build_date",
            "first_play_date",
            "extra_18",
        }:
            params[col] = _convert_to_date(value)
        else:
            params[col] = value

    # Add DATE_MODIFIED if not provided (required column)
    if "date_modified" not in normalized_data:
        columns.append("DATE_MODIFIED")
        params["date_modified"] = datetime.now()

    # Build the INSERT statement with RETURNING clause
    # Insert directly into config DB (no DB link)
    col_list = ", ".join(columns)
    param_list = ", ".join(f":{col.lower()}" for col in columns)

    sql = (
        f"INSERT INTO LVOUSR.CAMPAIGN ({col_list}) "
        f"VALUES ({param_list}) "
        f"RETURNING CAMPAIGN_ID INTO :out_campaign_id"
    )

    return CampaignInsert(sql=sql, params=params)


def _normalize_campaign_column(col: str) -> str:
    """Normalize column name to uppercase and validate."""
    normalized = col.upper()
    if normalized not in {c.upper() for c in CAMPAIGN_COLUMNS}:
        raise ValueError(f"Invalid campaign column: {col}")
    return normalized


def _validate_campaign_filters(filters: Mapping[str, object] | None) -> tuple[str, dict[str, Any]]:
    """Validate and build WHERE clause from filters for Oracle campaign queries.
    
    Supports operators: =, !=, >, >=, <, <=, like, in, not_in, between
    """
    if not filters:
        return "", {}
    
    allowed_columns = {c.upper() for c in CAMPAIGN_COLUMNS}
    clauses = []
    params: dict[str, Any] = {}
    counter = 1

    def next_param() -> str:
        nonlocal counter
        name = f"p{counter}"
        counter += 1
        return name

    for key, value in filters.items():
        column = key.upper()
        if column not in allowed_columns:
            raise ValueError(f"Invalid campaign filter column: {key}")

        op = "="
        operand = value
        if isinstance(value, (list, tuple)) and len(value) == 2:
            op = str(value[0]).lower()
            operand = value[1]
        elif isinstance(value, Mapping) and "op" in value:
            op = str(value["op"]).lower()
            operand = value.get("value")

        if op in {"eq", "="}:
            param = next_param()
            clauses.append(f"{column} = :{param}")
            params[param] = _convert_to_date(operand)
        elif op in {"neq", "!=", "<>"}:
            param = next_param()
            clauses.append(f"{column} <> :{param}")
            params[param] = _convert_to_date(operand)
        elif op in {"gt", ">"}:
            param = next_param()
            clauses.append(f"{column} > :{param}")
            params[param] = _convert_to_date(operand)
        elif op in {"gte", ">="}:
            param = next_param()
            clauses.append(f"{column} >= :{param}")
            params[param] = _convert_to_date(operand)
        elif op in {"lt", "<"}:
            param = next_param()
            clauses.append(f"{column} < :{param}")
            params[param] = _convert_to_date(operand)
        elif op in {"lte", "<="}:
            param = next_param()
            clauses.append(f"{column} <= :{param}")
            params[param] = _convert_to_date(operand)
        elif op == "like":
            param = next_param()
            clauses.append(f"{column} LIKE :{param}")
            params[param] = operand
        elif op in {"in", "not_in"}:
            if not isinstance(operand, (list, tuple, set)) or not operand:
                raise ValueError(f"{op} operator requires a non-empty list")
            bind_names = []
            for item in operand:
                param = next_param()
                params[param] = _convert_to_date(item)
                bind_names.append(f":{param}")
            comparator = "IN" if op == "in" else "NOT IN"
            clauses.append(f"{column} {comparator} ({', '.join(bind_names)})")
        elif op == "between":
            if not isinstance(operand, (list, tuple)) or len(operand) != 2:
                raise ValueError("between operator requires a list of two values")
            p1, p2 = next_param(), next_param()
            clauses.append(f"{column} BETWEEN :{p1} AND :{p2}")
            params[p1] = _convert_to_date(operand[0])
            params[p2] = _convert_to_date(operand[1])
        else:
            raise ValueError(f"Unknown filter operator: {op}")

    where_sql = " WHERE " + " AND ".join(clauses) if clauses else ""
    return where_sql, params


def build_campaign_select(
    filters: Mapping[str, object] | None = None,
    columns: list[str] | None = None,
    limit: int = 100,
    order_by: str | None = None,
) -> CampaignQuery:
    """Build a SELECT statement to query campaigns from the config DB.

    Campaigns are queried directly from the Oracle config database (LVOUSR.CAMPAIGN).

    Args:
        filters: Optional filters to apply (e.g., {"client_id": 123, "create_date": [">=", "2026-02-19"]})
        columns: Optional list of columns to select (defaults to CAMPAIGN_SELECT_COLUMNS)
        limit: Maximum rows to return (default 100, max 1000)
        order_by: Optional column to order by (e.g., "create_date DESC")

    Returns:
        CampaignQuery with SQL and parameters
    """
    limit = max(1, min(int(limit), 1000))
    
    # Validate and build column list
    if columns:
        validated_cols = [_normalize_campaign_column(c) for c in columns]
        col_list = ", ".join(validated_cols)
    else:
        col_list = ", ".join(CAMPAIGN_SELECT_COLUMNS)
    
    # Build WHERE clause
    where_sql, params = _validate_campaign_filters(filters)
    
    # Build ORDER BY clause
    order_sql = ""
    if order_by:
        parts = order_by.strip().split()
        col = _normalize_campaign_column(parts[0])
        direction = "DESC" if len(parts) > 1 and parts[1].upper() == "DESC" else "ASC"
        order_sql = f" ORDER BY {col} {direction}"
    else:
        order_sql = " ORDER BY CAMPAIGN_ID DESC"
    
    sql = f"SELECT {col_list} FROM LVOUSR.CAMPAIGN{where_sql}{order_sql} FETCH FIRST {limit} ROWS ONLY"
    
    return CampaignQuery(sql=sql, params=params)


def build_campaign_select_legacy(
    dialing_db: str,
    campaign_id: int | None = None,
    client_id: int | None = None,
    limit: int = 100,
) -> tuple[str, dict[str, Any]]:
    """Build a SELECT statement to query campaigns.

    Args:
        dialing_db: The DB link name
        campaign_id: Optional specific campaign ID to fetch
        client_id: Optional client ID to filter by
        limit: Maximum rows to return

    Returns:
        Tuple of (SQL string, parameters dict)
    """
    sql = f"SELECT * FROM LVOUSR.CAMPAIGN@{dialing_db}"
    params: dict[str, Any] = {}
    conditions = []

    if campaign_id is not None:
        conditions.append("CAMPAIGN_ID = :campaign_id")
        params["campaign_id"] = campaign_id

    if client_id is not None:
        conditions.append("CLIENT_ID = :client_id")
        params["client_id"] = client_id

    if conditions:
        sql += " WHERE " + " AND ".join(conditions)

    sql += " ORDER BY CAMPAIGN_ID DESC"
    sql += f" FETCH FIRST {limit} ROWS ONLY"

    return sql, params


def build_transaction_insert_from_select(
    dialing_db: str,
    campaign_id: int,
    source_query: str,
    source_params: dict[str, Any],
) -> tuple[str, dict[str, Any]]:
    """Build an INSERT INTO ... SELECT statement to copy transactions with a new campaign_id.

    This is used to create new transaction records from existing ones (e.g., failed SMS retry).
    The INSERT goes into the transaction table via DB link.

    Args:
        dialing_db: The DB link for the dialing database
        campaign_id: The new campaign ID to assign to the inserted records
        source_query: The SELECT query that identifies source records
        source_params: Parameters for the source query

    Returns:
        Tuple of (SQL string, parameters dict)
    """
    # The source query should select from transaction table
    # We'll insert into transaction with the new campaign_id
    
    # Key columns to copy from source (excluding overridden ones)
    source_columns = [
        "ACCOUNT",
        "PATIENT_FIRSTNAME",
        "PATIENT_LASTNAME",
        "GUARANTOR_FIRSTNAME",
        "GUARANTOR_LASTNAME",
        "PATIENT_PHONE1",
        "PATIENT_PHONE2",
        "PATIENT_EMAIL",
        "CLIENT_ID",
        "TOTAL_AMOUNT",
        "ACCOUNT_TO_SPEAK",
        "AMOUNT_TO_SPEAK",
        "EXTRA_1",
        "EXTRA_2",
        "EXTRA_3",
        "EXTRA_4",
        "EXTRA_5",
        "LVTRANSACTION_TYPE",
        "LVTRANSACTION_SUBTYPE",
    ]
    
    # Full insert columns including auto-generated and overridden ones
    insert_columns = ["ACCT_TRANSACTION_ID"] + source_columns + ["B_ACTIVE", "CAMPAIGN_ID", "DATE_MODIFIED"]
    
    # Build SELECT list - use sequence for ID, copy source columns, override the rest
    select_cols = [
        f"LVOUSR.ACCT_TRANSACTION_ID_LOCAL_SEQ.NEXTVAL@{dialing_db}"
    ] + source_columns + [
        "1 AS B_ACTIVE",
        ":new_campaign_id AS CAMPAIGN_ID",
        "SYSDATE AS DATE_MODIFIED",
    ]
    
    select_list = ", ".join(select_cols)
    col_list = ", ".join(insert_columns)
    
    sql = (
        f"INSERT INTO LVOUSR.TRANSACTION@{dialing_db} ({col_list}) "
        f"SELECT {select_list} FROM ({source_query})"
    )
    
    params = {**source_params, "new_campaign_id": campaign_id}
    
    return sql, params


def build_count_query_for_campaign(
    dialing_db: str,
    filters: Mapping[str, Any],
    table_names: list[str] | None = None,
) -> tuple[str, dict[str, Any]]:
    """Build a COUNT query to check if records exist before creating a campaign.

    Args:
        dialing_db: The DB link for the transaction table
        filters: Filters to identify matching records
        table_names: Optional list of table names (including archives) to query.
                     If not provided, only queries the main transaction table.

    Returns:
        Tuple of (SQL string, parameters dict)
    """
    from .transaction import _validate_filters
    
    where_sql, params = _validate_filters(filters, table="transaction")
    
    if table_names and len(table_names) > 1:
        # Query across multiple tables (main + archives) using UNION ALL
        parts = [f"SELECT 1 FROM {name}{where_sql}" for name in table_names]
        union_sql = " UNION ALL ".join(parts)
        sql = f"SELECT COUNT(*) FROM ({union_sql})"
    else:
        # Query only the main transaction table
        sql = f"SELECT COUNT(*) FROM LVOUSR.TRANSACTION@{dialing_db}{where_sql}"
    
    return sql, params


def build_source_query_for_campaign(
    filters: Mapping[str, Any],
    table_names: list[str],
    max_records: int | None = None,
) -> tuple[str, dict[str, Any]]:
    """Build a SELECT query across transaction tables (main + archives) for campaign insert.

    Args:
        filters: Filters to identify matching records
        table_names: List of table names (including archives) to query
        max_records: Optional maximum number of records to return

    Returns:
        Tuple of (SQL string, parameters dict)
    """
    from .transaction import _validate_filters
    
    where_sql, params = _validate_filters(filters, table="transaction")
    
    # Only select the columns we actually need for insert
    # This avoids issues with SELECT * across UNION
    select_columns = [
        "ACCOUNT",
        "PATIENT_FIRSTNAME",
        "PATIENT_LASTNAME",
        "GUARANTOR_FIRSTNAME",
        "GUARANTOR_LASTNAME",
        "PATIENT_PHONE1",
        "PATIENT_PHONE2",
        "PATIENT_EMAIL",
        "CLIENT_ID",
        "TOTAL_AMOUNT",
        "ACCOUNT_TO_SPEAK",
        "AMOUNT_TO_SPEAK",
        "EXTRA_1",
        "EXTRA_2",
        "EXTRA_3",
        "EXTRA_4",
        "EXTRA_5",
        "LVTRANSACTION_TYPE",
        "LVTRANSACTION_SUBTYPE",
    ]
    col_list = ", ".join(select_columns)
    
    if len(table_names) > 1:
        # Query across multiple tables using UNION ALL
        parts = [f"SELECT {col_list} FROM {name}{where_sql}" for name in table_names]
        sql = " UNION ALL ".join(parts)
    else:
        sql = f"SELECT {col_list} FROM {table_names[0]}{where_sql}"
    
    # Apply max_records limit if specified
    if max_records is not None and max_records > 0:
        sql = f"SELECT * FROM ({sql}) WHERE ROWNUM <= {max_records}"
    
    return sql, params
